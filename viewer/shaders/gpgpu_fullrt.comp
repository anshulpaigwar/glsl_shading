#version 430 core

layout(binding = 0, rgba32f) uniform writeonly image2D framebuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform float shininess;
uniform float eta;
uniform vec3 bbmin;
uniform vec3 bbmax;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;

#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.000001


struct hitinfo_t {
    vec4 t;
    int hit_vptr;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};


float difuse_light(in vec3 vertNormal, in vec3 lightVector) {
    return  max(dot(normalize(vertNormal), normalize(lightVector)),0.0);
}

float specular_light(in vec3 vertNormal, in vec3 lightVector, in vec3 eyeVector)
{
    vec3 halfVector  = normalize(normalize(eyeVector) + normalize(lightVector));

    float cos_angle = (dot(halfVector,lightVector))/(length(halfVector)*length(lightVector));

    float ci = pow(eta*eta -1 + pow(cos_angle, 2), 0.5);

    float Fs = pow((cos_angle - ci)/(cos_angle + ci),2);
    float Fp = pow((eta* eta* cos_angle - ci)/(eta* eta* cos_angle + ci),2);

    float Fresnel_coeff = 0.5*(Fs + Fp);

    return Fresnel_coeff * pow(max(dot(normalize(vertNormal), halfVector),0.0),shininess);


}




bool intersectBoundingBox(vec4 origin, vec4 dir) {
	// TODO
	//
    vec3 tmin = (bbmin - origin.xyz)/dir.xyz;
	vec3 tmax =     (bbmax - origin.xyz)/dir.xyz;

    float IN = max(min(min(tmin.x,tmin.y),tmin.z), min(min(tmax.x,tmax.y),tmax.z));
    float OUT = min(max(max(tmin.x,tmin.y),tmin.z), max(max(tmax.x,tmax.y),tmax.z));
    if(OUT > IN)
        return true;
    else
        return false;
}

bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist)
{
	// TODO
	const float EPSILON = 0.0000001;
	vec4 v0 = vertices[indices[ptr]];
    vec4 v1 = vertices[indices[ptr + 1]];
    vec4 v2 = vertices[indices[ptr + 2]];

    vec3 t = v0.xyz - origin.xyz;
    vec3 e1 = v1.xyz - v0.xyz;
    vec3 e2 = v2.xyz - v0.xyz;
    vec3 p = cross(dir.xyz , e2);
    vec3 q = cross(t , e1);

    float a = dot(p,e1);
    if (a > -EPSILON && a < EPSILON)
        return false;
    float f = 1.0/a;

    float alpha  = dot(p,t)*f;
    float beta = dot(q,dir.xyz)*f;

    if (alpha < 0.0 || alpha > 1.0)
        return false;

    if (beta < 0.0 || beta + alpha > 1.0)
        return false;

    float lambda = dot(q,e2)*f;

    dist = vec4(alpha,beta,1-alpha-beta,lambda);
    // if (lambda > EPSILON) return true;
    // else false;
    return true;

    // if (lambda > EPSILON) // ray intersection
    // {
    //     //vec4 IntersectionPoint = origin + dir * lambda;
    //     dist = vec4(alpha,beta,1-alpha-beta,lambda);
    //     return true;
    // }
    // else // This means that there is a line intersection but not a ray intersection.
    //     return false;
}

vec4 interpolateNormal(hitinfo_t h)
{
	// TODO
    vec4 N0 = normalize(Normals[indices[ptr]]);
    vec4 N1 = normalize(Normals[indices[ptr + 1]]);
    vec4 N2 = normalize(Normals[indices[ptr + 2]]);

    vec4 N_interpolate = normalize(h.t.x *N0 + h.t.y *N1 + h.t.z*N3);
    return N_interpolate;
}

vec4 interpolateColor(hitinfo_t h)
{
	// TODO
	vec4 N = interpolateNormal(h);
	return vec4(1);
}

bool isIntersected(vec4 origin, vec4 dir, out hitinfo_t h)
{
    vec4 dist; // stores distance + barycentric coord
	bool hit = false;
	h.t.x = radius * MAX_SCENE_BOUNDS;
	if(intersectBoundingBox(origin, dir)) {
		for(int j = 0; j < indices.length(); j += 3) {
			if(intersectTriangle(origin, dir, j, dist)) {
                h.t = dist;
                h.hit_vptr = j;
				return true;
			}
		}
	}
	return false;
}

const int MAX_TRACE = 1;


vec4 trace(vec4 origin, vec4 dir)
{
	// TODO: trace a ray in the scene, see what it intersects, bounce around

    hitinfo_t h;
    if(isIntersected(origin,dir,h))
        // return interpolateColor(h);
        return vec4(1,0,0,0);
  return vec4(0.50,0.50,0.50,0);

    // vec4 dist;
    // for(int j = 0; j < indices.length(); j += 3) {
	// 	if(intersectTriangle(origin, dir, j, dist))
	// 		return vec4(1,0,0,0);
    // }
    // return vec4(0.50,0.50,0.50,0);
}


layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy); // interger vector
    ivec2 size = imageSize(framebuffer); // result of compute shader stored in framebuffer
    if (pix.x >= size.x || pix.y >= size.y) {
        return; // if pixel we are working on is beyond the size of image size then return
    }
    vec2 pos = pix / (size - vec2(0.5,0.5));
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1.,1.);

    // Step 1: I need pixel coordinates.
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);

    imageStore(framebuffer, pix, color);
}
